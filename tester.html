<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Real‚ÄëTime Typing Mirror ‚Äî 1 HTML File</title>
  <style>
    :root{
      --bg:#3d1a50; --card:#2d1540; --muted:#8b5cf6; --text:#f3e8ff; --accent:#c084fc; --good:#a78bfa; --warn:#fbbf24;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:ui-sans-serif,system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial;background:linear-gradient(135deg,#1e0836, #3d1a50 50%, #581c87);color:var(--text);}
    .wrap{max-width:1100px;margin:24px auto;padding:16px}
    header{display:flex;gap:14px;align-items:center;justify-content:space-between;margin-bottom:16px}
    h1{font-size:clamp(20px,5vw,30px);margin:0;font-weight:800;letter-spacing:.3px;background:linear-gradient(90deg,#e9d5ff,#c084fc);-webkit-background-clip:text;-webkit-text-fill-color:transparent;background-clip:text}
    .badge{font-size:12px;padding:6px 10px;border-radius:999px;background:linear-gradient(90deg,#6b21a8,#7e22ce);border:1px solid #a855f7;box-shadow:0 0 20px rgba(168,85,247,.3)}
    .grid{display:grid;grid-template-columns:1.2fr .8fr;gap:16px}
    @media (max-width:900px){.grid{grid-template-columns:1fr}}
    .card{background:linear-gradient(135deg,rgba(88,28,135,.3),rgba(109,40,217,.2));backdrop-filter:blur(10px);border:1px solid rgba(168,85,247,.4);border-radius:18px;box-shadow:0 10px 40px rgba(88,28,135,.5),0 0 80px rgba(168,85,247,.1);overflow:hidden}
    .card .hd{padding:14px 16px;border-bottom:1px solid rgba(168,85,247,.3);background:linear-gradient(90deg,rgba(109,40,217,.3),rgba(88,28,135,.2));display:flex;align-items:center;gap:10px}
    .card .hd h2{margin:0;font-size:16px;color:#e9d5ff}
    .card .bd{padding:16px}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    input[type="text"], textarea{width:100%;padding:12px 14px;border-radius:12px;border:1px solid rgba(168,85,247,.5);background:rgba(30,8,54,.6);color:var(--text);outline:none;font-family:inherit;transition:all .3s ease}
    input[type="text"]:focus, textarea:focus{border-color:#a855f7;box-shadow:0 0 20px rgba(168,85,247,.4);background:rgba(30,8,54,.8)}
    textarea{min-height:200px;resize:vertical;font-size:14px;line-height:1.5}
    textarea.code-mode{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:rgba(15,5,30,.9);border-color:#a855f7;tab-size:2;white-space:pre}
    button{appearance:none;border:none;background:linear-gradient(135deg,#7c3aed,#6d28d9);border:1px solid #8b5cf6;color:#f3e8ff;padding:10px 14px;border-radius:12px;cursor:pointer;font-weight:700;transition:all .3s ease;box-shadow:0 4px 15px rgba(124,58,237,.3)}
    button:hover{transform:translateY(-2px);box-shadow:0 6px 20px rgba(124,58,237,.5)}
    button.primary{background:linear-gradient(135deg,#a855f7,#9333ea);border-color:#c084fc;color:#fff;box-shadow:0 4px 20px rgba(168,85,247,.5)}
    button.primary:hover{box-shadow:0 6px 25px rgba(168,85,247,.7)}
    button.ghost{background:transparent;box-shadow:none}
    button.ghost:hover{background:rgba(124,58,237,.2)}
    button:disabled{opacity:.55;cursor:not-allowed;transform:none}
    .help{font-size:13px;color:#d8b4fe}
    .muted{opacity:.8}
    .tag{padding:4px 8px;border-radius:8px;border:1px dashed #a855f7;font-size:12px;background:rgba(168,85,247,.1)}
    .qr{display:grid;place-items:center;background:rgba(30,8,54,.6);border:2px dashed rgba(168,85,247,.5);border-radius:14px;padding:10px;min-height:160px}
    .log{font-family:ui-monospace,SFMono-Regular,Menlo,Consolas,monospace;background:rgba(30,8,54,.6);border:1px solid rgba(168,85,247,.4);border-radius:12px;padding:10px;max-height:200px;overflow:auto;color:#e9d5ff}
    .consent{display:flex;gap:8px;align-items:flex-start;font-size:14px}
    .pill{display:inline-flex;align-items:center;gap:6px;padding:6px 10px;border-radius:999px;background:linear-gradient(135deg,#7c3aed,#6d28d9);border:1px solid #a855f7;box-shadow:0 0 20px rgba(124,58,237,.4)}
    .status-dot{width:8px;height:8px;border-radius:50%;background:#dc2626;display:inline-block;box-shadow:0 0 10px currentColor}
    .status-dot.on{background:#a78bfa;box-shadow:0 0 15px #a78bfa}
    .id{font-variant:tabular-nums;color:#c084fc}
    footer{margin-top:18px;font-size:12px;opacity:.8}
    .copy{font-size:12px;color:#d8b4fe}
    .output-frame{width:100%;min-height:300px;border:1px solid rgba(168,85,247,.4);border-radius:12px;background:#fff;margin-top:12px}
    .run-controls{display:flex;gap:8px;margin-top:10px;align-items:center}
    .user-list{margin-top:12px;max-height:180px;overflow:auto}
    .user-item{display:flex;align-items:center;justify-content:space-between;padding:8px 10px;margin:4px 0;background:rgba(30,8,54,.4);border:1px solid rgba(168,85,247,.3);border-radius:8px}
    .user-item .user-id{font-family:ui-monospace,monospace;font-size:12px;color:#c084fc}
    .user-item .user-controls{display:flex;gap:6px}
    .user-item button{padding:4px 8px;font-size:11px}
    .user-item.muted{opacity:.6;border-color:#dc2626}
    .user-item.muted .user-id{color:#fca5a5}
    .draw-canvas{width:100%;height:400px;border:1px solid rgba(168,85,247,.4);border-radius:12px;background:#fff;cursor:crosshair;display:none;margin-top:12px}
    .draw-controls{display:none;gap:10px;margin-top:10px;align-items:center;flex-wrap:wrap}
    .color-btn{width:32px;height:32px;border-radius:8px;cursor:pointer;border:2px solid transparent;transition:all .2s}
    .color-btn.active{border-color:#fff;box-shadow:0 0 10px currentColor}
    .screen-container{margin-top:12px;display:none}
    .screen-video{width:100%;max-height:500px;border:1px solid rgba(168,85,247,.4);border-radius:12px;background:#000;display:block}
    .screen-info{font-size:13px;color:#d8b4fe;margin-top:8px;display:flex;align-items:center;gap:8px}
    .screen-info .presenter{color:#a78bfa;font-weight:700}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div class="row">
        <h1>Real‚ÄëTime Typing Mirror</h1>
        <span class="badge">single‚Äëfile ‚Ä¢ P2P (WebRTC via PeerJS)</span>
      </div>
      <div class="row">
        <div class="pill"><span class="status-dot" id="dot"></span><span id="netStatus">offline</span></div>
        <div class="pill" style="background:linear-gradient(135deg,#9333ea,#7e22ce)"><span id="userCount">0</span> users</div>
        <div class="pill" id="lockIndicator" style="display:none;background:linear-gradient(135deg,#dc2626,#b91c1c)">üîí Locked</div>
      </div>
    </header>

    <div class="grid">
      <section class="card">
        <div class="hd">
          <h2>Shared Text Area</h2>
          <span class="tag">what you type is visible to everyone in the room</span>
          <div style="margin-left:auto;display:flex;gap:8px">
            <button id="textModeBtn" class="ghost" style="font-size:13px;padding:6px 12px">üìù Text</button>
            <button id="codeModeBtn" class="ghost" style="font-size:13px;padding:6px 12px">üíª Code</button>
            <button id="drawModeBtn" class="ghost" style="font-size:13px;padding:6px 12px">üé® Draw</button>
          </div>
        </div>
        <div class="bd">
          <div class="consent" style="margin-bottom:10px">
            <input type="checkbox" id="consentBox">
            <label for="consentBox">I understand and consent that anything I type below will be shared in real time with everyone connected to this room. Only use this with people who agree.</label>
          </div>
          <textarea id="shared" placeholder="Start typing after you connect & consent‚Ä¶" disabled></textarea>
          <div class="run-controls" id="runControls" style="display:none">
            <button id="runBtn" class="primary">‚ñ∂ Run Code</button>
            <button id="clearBtn" class="ghost">Clear Output</button>
            <span class="help">HTML/CSS/JS supported</span>
          </div>
          <iframe id="outputFrame" class="output-frame" sandbox="allow-scripts" style="display:none"></iframe>
          <canvas id="drawCanvas" class="draw-canvas"></canvas>
          <div class="draw-controls" id="drawControls">
            <span class="help">Color:</span>
            <button class="color-btn active" data-color="#000000" style="background:#000"></button>
            <button class="color-btn" data-color="#dc2626" style="background:#dc2626"></button>
            <button class="color-btn" data-color="#ea580c" style="background:#ea580c"></button>
            <button class="color-btn" data-color="#16a34a" style="background:#16a34a"></button>
            <button class="color-btn" data-color="#2563eb" style="background:#2563eb"></button>
            <button class="color-btn" data-color="#9333ea" style="background:#9333ea"></button>
            <label class="help" style="margin-left:10px">Size: <input type="range" id="brushSize" min="1" max="20" value="3" style="width:100px"></label>
            <button id="clearCanvas" class="ghost">Clear Canvas</button>
          </div>
          <div class="screen-container" id="screenContainer">
            <video id="screenVideo" class="screen-video" autoplay playsinline></video>
            <div class="screen-info" id="screenInfo">
              <span>üì∫ <span class="presenter" id="presenterName">Someone</span> is sharing their screen</span>
            </div>
          </div>
          <div class="row" style="justify-content:space-between;margin-top:10px">
            <span class="help">Tip: Open this page on your phone and join the same room to see live typing.</span>
            <span class="copy">Characters: <span id="count">0</span></span>
          </div>
        </div>
      </section>

      <aside class="card">
        <div class="hd"><h2>Connect</h2></div>
        <div class="bd">
          <div class="row" style="margin-bottom:10px">
            <button id="createBtn" class="primary">Create room</button>
            <button id="joinBtn">Join room</button>
            <button id="lockBtn" class="ghost" disabled>Lock</button>
            <button id="shareScreenBtn" class="ghost" disabled>üì∫ Share Screen</button>
            <button id="leaveBtn" class="ghost" disabled>Leave</button>
          </div>

          <div class="row" style="margin-bottom:10px">
            <input type="text" id="roomInput" placeholder="Room ID (auto if empty)" maxlength="24" />
            <button id="copyLink">Copy link</button>
          </div>

          <div class="qr" id="qrBox"><div id="qrcode" aria-label="QR code"></div></div>
          
          <div style="margin-top:12px" class="help">
            Anyone with the link/ID can join this room. Data is peer‚Äëto‚Äëpeer and not stored.
          </div>

          <h3 style="margin:16px 0 6px 0;font-size:14px;opacity:.9">Event log</h3>
          <div class="log" id="log" aria-live="polite"></div>

          <div id="userListContainer" style="display:none">
            <h3 style="margin:16px 0 6px 0;font-size:14px;opacity:.9">Connected Users</h3>
            <div class="user-list" id="userList"></div>
          </div>
        </div>
      </aside>
    </div>

    <footer>
      Built for demos & collaborative note‚Äëtaking. Do not use for secret or sensitive data.
    </footer>
  </div>

  <!-- PeerJS (WebRTC helper) -->
  <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
  <!-- QRCode generator -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>

  <script>
  (()=>{
    const $ = (s)=>document.querySelector(s);
    const logEl = $('#log');
    const dot = $('#dot');
    const netStatus = $('#netStatus');
    const ta = $('#shared');
    const count = $('#count');
    const consentBox = $('#consentBox');
    const roomInput = $('#roomInput');
    const qrBox = $('#qrcode');
    const userCount = $('#userCount');
    const lockIndicator = $('#lockIndicator');
    const textModeBtn = $('#textModeBtn');
    const codeModeBtn = $('#codeModeBtn');
    const drawModeBtn = $('#drawModeBtn');
    const runBtn = $('#runBtn');
    const clearBtn = $('#clearBtn');
    const runControls = $('#runControls');
    const outputFrame = $('#outputFrame');
    const drawCanvas = $('#drawCanvas');
    const drawControls = $('#drawControls');
    const brushSize = $('#brushSize');
    const clearCanvas = $('#clearCanvas');
    const shareScreenBtn = $('#shareScreenBtn');
    const screenContainer = $('#screenContainer');
    const screenVideo = $('#screenVideo');
    const presenterName = $('#presenterName');
    const userListContainer = $('#userListContainer');
    const userList = $('#userList');

    // state
    let peer = null;        // our PeerJS instance
    let isHost = false;     // am I the room host?
    let roomId = null;      // string
    let isLocked = false;   // is room locked?
    let currentMode = 'text'; // 'text' | 'code' | 'draw'
    let isMuted = false;    // am I muted by host?
    const conns = new Map();// peerId -> DataConnection
    const userStates = new Map();// peerId -> {muted: bool}
    
    // Drawing state
    let isDrawing = false;
    let ctx = null;
    let currentColor = '#000000';
    let currentBrushSize = 3;

    // Screen sharing state
    let isSharing = false;
    let screenStream = null;
    let currentPresenter = null;

    // utils
    const randId = () => Math.random().toString(36).slice(2,8).toUpperCase();
    const linkFor = (id) => location.origin + location.pathname + '#'+ encodeURIComponent(id);
    const setOnline = (on)=>{ dot.classList.toggle('on',!!on); netStatus.textContent= on? 'connected' : 'offline'; }
    const log = (msg)=>{ const t = new Date().toLocaleTimeString(); logEl.innerHTML = `[${t}] ${msg}<br>` + logEl.innerHTML; }
    const setHash = (id)=>{ history.replaceState(null,'', linkFor(id)); };
    const updateQR = (id)=>{ qrBox.innerHTML=''; new QRCode(qrBox,{ text: linkFor(id), width:160, height:160 }); };
    const broadcast = (payload)=>{ conns.forEach(c=>{ try{ c.open && c.send(payload);}catch(e){} }); };
    const updateUserCount = ()=>{ const total = conns.size + (peer ? 1 : 0); userCount.textContent = total; };
    const updateLockUI = ()=>{ lockIndicator.style.display = isLocked ? 'inline-flex' : 'none'; $('#lockBtn').textContent = isLocked ? 'Unlock' : 'Lock'; };
    const updateUserList = ()=>{
      if(!isHost){ userListContainer.style.display = 'none'; return; }
      userListContainer.style.display = conns.size > 0 ? 'block' : 'none';
      userList.innerHTML = '';
      conns.forEach((conn, peerId)=>{
        const state = userStates.get(peerId) || {muted: false};
        const div = document.createElement('div');
        div.className = 'user-item' + (state.muted ? ' muted' : '');
        div.innerHTML = `
          <span class="user-id">${peerId}</span>
          <div class="user-controls">
            <button class="ghost transfer-btn">Make Host</button>
            <button class="ghost mute-btn">${state.muted ? 'Unmute' : 'Mute'}</button>
            <button class="ghost kick-btn">Kick</button>
          </div>
        `;
        div.querySelector('.transfer-btn').addEventListener('click', ()=>transferHost(peerId));
        div.querySelector('.mute-btn').addEventListener('click', ()=>toggleMute(peerId));
        div.querySelector('.kick-btn').addEventListener('click', ()=>kickUser(peerId));
        userList.appendChild(div);
      });
    };

    // sound notifications
    const playSound = (freq, duration = 200) => {
      try {
        const ctx = new (window.AudioContext || window.webkitAudioContext)();
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        osc.frequency.value = freq;
        osc.type = 'sine';
        gain.gain.setValueAtTime(0.3, ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, ctx.currentTime + duration / 1000);
        osc.start();
        osc.stop(ctx.currentTime + duration / 1000);
      } catch(e) {}
    };
    const soundJoin = () => { playSound(800, 150); setTimeout(() => playSound(1000, 150), 100); };
    const soundLeave = () => { playSound(600, 150); setTimeout(() => playSound(400, 150), 100); };

    // Host controls
    const toggleMute = (peerId)=>{
      if(!isHost) return;
      const state = userStates.get(peerId) || {muted: false};
      state.muted = !state.muted;
      userStates.set(peerId, state);
      const conn = conns.get(peerId);
      if(conn?.open){ try{ conn.send({type:'mute', muted: state.muted}); }catch(e){} }
      log(`User ${peerId} ${state.muted ? 'muted' : 'unmuted'}`);
      updateUserList();
    };

    const kickUser = (peerId)=>{
      if(!isHost) return;
      const conn = conns.get(peerId);
      if(conn?.open){ try{ conn.send({type:'kick'}); conn.close(); }catch(e){} }
      conns.delete(peerId);
      userStates.delete(peerId);
      log(`User ${peerId} kicked`);
      updateUserCount();
      updateUserList();
      soundLeave();
    };

    const transferHost = (peerId)=>{
      if(!isHost) return;
      if(!confirm(`Transfer host privileges to ${peerId}?`)) return;
      const conn = conns.get(peerId);
      if(conn?.open){
        try{
          conn.send({type:'transfer-host', newHostId: peerId, connections: Array.from(conns.keys()).filter(id=>id!==peerId)});
          isHost = false;
          $('#lockBtn').disabled = true;
          updateUserList();
          log(`Host transferred to ${peerId}`);
        }catch(e){}
      }
    };

    // consent gating
    const setTypingEnabled = ()=>{ ta.disabled = !consentBox.checked || isMuted || conns.size===0 && !isHost; };
    consentBox.addEventListener('change', setTypingEnabled);

    // character counter
    ta.addEventListener('input', ()=>{
      count.textContent = ta.value.length;
      if(!consentBox.checked) return; // don't send without consent
      const msg = {type:'text', value: ta.value, from: peer?.id || 'local', ts: Date.now()};
      if(isHost){ broadcast(msg); } else { // send to host only
        conns.forEach(c=>{ if(c.open){ try{ c.send(msg);}catch(e){} } });
      }
    });

    // Debounce typing events for efficiency
    let debTimer=null; const debounce=(fn,ms)=>{ return (...a)=>{ clearTimeout(debTimer); debTimer=setTimeout(()=>fn(...a),ms); } };
    ta.removeEventListener('input',()=>{});
    ta.addEventListener('input', debounce(()=>{
      count.textContent = ta.value.length;
      if(!consentBox.checked) return;
      const msg = {type:'text', value: ta.value, from: peer?.id || 'local', ts: Date.now()};
      if(isHost){ broadcast(msg);} else { conns.forEach(c=>{ if(c.open){ c.send(msg);} }); }
    },120));

    // host receive + relay; client receive
    const handleMessage = (data, fromId)=>{
      if(data?.type==='text'){
        // Host: check if sender is muted
        if(fromId && isHost){
          const senderState = userStates.get(fromId);
          if(senderState?.muted){ return; } // ignore muted users
          // relay to everyone except sender
          conns.forEach((c,id)=>{ if(id!==fromId && c.open){ try{ c.send(data);}catch(e){} } });
        }
        // update local textarea without triggering resend loop
        const caret = ta.selectionStart;
        const wasFocused = document.activeElement===ta;
        ta.value = data.value;
        count.textContent = ta.value.length;
        if(wasFocused){ ta.setSelectionRange(caret, caret); }
      } else if(data?.type==='lock'){
        isLocked = data.locked;
        updateLockUI();
        log(isLocked ? 'Room locked by host' : 'Room unlocked by host');
      } else if(data?.type==='mute'){
        isMuted = data.muted;
        setTypingEnabled();
        log(isMuted ? 'You have been muted by the host' : 'You have been unmuted by the host');
      } else if(data?.type==='kick'){
        log('You have been kicked by the host');
        setTimeout(()=>$('#leaveBtn').click(), 500);
      } else if(data?.type==='transfer-host'){
        isHost = true;
        $('#lockBtn').disabled = false;
        log('You are now the host!');
        updateUserList();
      } else if(data?.type==='draw'){
        drawOnCanvas(data.x, data.y, data.x2, data.y2, data.color, data.size);
      } else if(data?.type==='clear-canvas'){
        clearCanvasLocal();
      } else if(data?.type==='screen-start'){
        currentPresenter = data.presenter;
        presenterName.textContent = data.presenter;
        screenContainer.style.display = 'block';
        log(`${data.presenter} started screen sharing`);
      } else if(data?.type==='screen-stop'){
        stopScreenDisplay();
        log(`${data.presenter} stopped screen sharing`);
      } else if(data?.type==='screen-offer'){
        handleScreenOffer(data, fromId);
      } else if(data?.type==='screen-answer'){
        handleScreenAnswer(data);
      } else if(data?.type==='screen-ice'){
        handleScreenIce(data);
      }
    };

    // Create room (host)
    $('#createBtn').addEventListener('click', async ()=>{
      if(peer){ log('Already connected.'); return; }
      isHost = true;
      roomId = (roomInput.value || randId()).toUpperCase();
      roomInput.value = roomId;
      setHash(roomId); updateQR(roomId);
      peer = new Peer(roomId, { debug: 1 }); // uses PeerServer Cloud
      setOnline(false);
      log(`Creating room <b class="id">${roomId}</b>‚Ä¶`);

      peer.on('open', ()=>{ setOnline(true); $('#leaveBtn').disabled=false; $('#lockBtn').disabled=false; $('#shareScreenBtn').disabled=false; log('Room is live. Waiting for guests‚Ä¶'); setTypingEnabled(); updateUserCount(); });
      peer.on('connection', (conn)=>{
        // Reject if locked
        if(isLocked){
          log(`Guest <b>${conn.peer}</b> rejected (room locked)`);
          try{ conn.close(); }catch(e){}
          return;
        }
        conns.set(conn.peer, conn);
        userStates.set(conn.peer, {muted: false});
        log(`Guest connected: <b>${conn.peer}</b>`);
        updateUserCount();
        updateUserList();
        soundJoin();
        // send current state immediately
        conn.on('open', ()=>{ 
          conn.send({type:'text', value: ta.value, from: peer.id, ts: Date.now()});
          conn.send({type:'lock', locked: isLocked});
          setTypingEnabled(); 
        });
        conn.on('data', (d)=> handleMessage(d, conn.peer));
        conn.on('close', ()=>{ conns.delete(conn.peer); userStates.delete(conn.peer); log(`Guest left: <b>${conn.peer}</b>`); setTypingEnabled(); updateUserCount(); updateUserList(); soundLeave(); });
        conn.on('error', (e)=> log(`Conn error: ${e.message}`));
      });
      peer.on('disconnected', ()=>{ setOnline(false); });
      peer.on('error', (e)=>{ log(`Peer error: ${e.type||'error'} ‚Äî ${e.message}`); });
    });

    // Join room (client)
    $('#joinBtn').addEventListener('click', ()=>{
      if(peer){ log('Already connected.'); return; }
      const hashId = (location.hash||'').slice(1);
      roomId = (roomInput.value || hashId || '').toUpperCase();
      if(!roomId){ alert('Enter a Room ID or open a link with a room hash.'); return; }
      roomInput.value = roomId; setHash(roomId); updateQR(roomId);
      peer = new Peer(undefined, { debug: 1 });
      setOnline(false);
      log(`Joining room <b class="id">${roomId}</b>‚Ä¶`);
      peer.on('open', ()=>{
        const conn = peer.connect(roomId, { reliable: true });
        conn.on('open', ()=>{ conns.set(roomId, conn); setOnline(true); $('#leaveBtn').disabled=false; $('#shareScreenBtn').disabled=false; log('Connected to host.'); setTypingEnabled(); updateUserCount(); soundJoin(); });
        conn.on('data', (d)=> handleMessage(d, roomId));
        conn.on('close', ()=>{ conns.delete(roomId); setOnline(false); log('Disconnected from host.'); setTypingEnabled(); updateUserCount(); soundLeave(); });
        conn.on('error', (e)=> log(`Conn error: ${e.message}`));
      });
      peer.on('error', (e)=>{ log(`Peer error: ${e.type||'error'} ‚Äî ${e.message}`); });
    });

    // Lock/Unlock button (host only)
    $('#lockBtn').addEventListener('click', ()=>{
      if(!isHost) return;
      isLocked = !isLocked;
      updateLockUI();
      broadcast({type:'lock', locked: isLocked});
      log(isLocked ? 'Room locked.' : 'Room unlocked.');
    });

    // Leave/cleanup
    $('#leaveBtn').addEventListener('click', ()=>{
      if(isSharing) stopScreenShare();
      conns.forEach(c=>{ try{ c.close(); }catch(e){} });
      conns.clear();
      userStates.clear();
      if(peer){ try{ peer.destroy(); }catch(e){} }
      peer = null; isHost = false; isMuted = false; setOnline(false); $('#leaveBtn').disabled=true; $('#lockBtn').disabled=true; $('#shareScreenBtn').disabled=true; log('Left room.'); setTypingEnabled(); updateUserCount(); updateUserList();
    });

    // Copy link button
    $('#copyLink').addEventListener('click', async ()=>{
      const id = (roomInput.value || '').toUpperCase() || randId();
      roomInput.value = id; setHash(id); updateQR(id);
      const url = linkFor(id);
      try{ await navigator.clipboard.writeText(url); log(`Link copied: <span class="id">${url}</span>`);}catch(e){
        prompt('Copy this link:', url);
      }
    });

    // Pre-fill from hash if present
    const hash = (location.hash||'').slice(1);
    if(hash){ roomInput.value = decodeURIComponent(hash.toUpperCase()); updateQR(roomInput.value); }

    // Mode switching
    const setMode = (mode)=>{
      currentMode = mode;
      textModeBtn.classList.toggle('primary', mode==='text');
      codeModeBtn.classList.toggle('primary', mode==='code');
      drawModeBtn.classList.toggle('primary', mode==='draw');
      
      ta.style.display = (mode==='text' || mode==='code') ? 'block' : 'none';
      ta.classList.toggle('code-mode', mode==='code');
      runControls.style.display = mode==='code' ? 'flex' : 'none';
      drawCanvas.style.display = mode==='draw' ? 'block' : 'none';
      drawControls.style.display = mode==='draw' ? 'flex' : 'none';
      
      if(mode!=='code') outputFrame.style.display = 'none';
      
      if(mode==='draw' && !ctx){
        ctx = drawCanvas.getContext('2d');
        drawCanvas.width = drawCanvas.offsetWidth;
        drawCanvas.height = drawCanvas.offsetHeight;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
      }
      
      log(`Switched to ${mode} mode.`);
    };

    textModeBtn.addEventListener('click', ()=>setMode('text'));
    codeModeBtn.addEventListener('click', ()=>setMode('code'));
    drawModeBtn.addEventListener('click', ()=>setMode('draw'));

    // Run code
    runBtn.addEventListener('click', ()=>{
      const code = ta.value;
      outputFrame.style.display = 'block';
      const doc = outputFrame.contentDocument || outputFrame.contentWindow.document;
      doc.open();
      doc.write(code);
      doc.close();
      log('Code executed.');
    });

    // Clear output
    clearBtn.addEventListener('click', ()=>{
      outputFrame.style.display = 'none';
      const doc = outputFrame.contentDocument || outputFrame.contentWindow.document;
      doc.open();
      doc.write('');
      doc.close();
      log('Output cleared.');
    });

    // Drawing functions
    const getMousePos = (e)=>{
      const rect = drawCanvas.getBoundingClientRect();
      const scaleX = drawCanvas.width / rect.width;
      const scaleY = drawCanvas.height / rect.height;
      return {
        x: (e.clientX - rect.left) * scaleX,
        y: (e.clientY - rect.top) * scaleY
      };
    };

    const getTouchPos = (e)=>{
      if(e.touches.length>0){
        const rect = drawCanvas.getBoundingClientRect();
        const scaleX = drawCanvas.width / rect.width;
        const scaleY = drawCanvas.height / rect.height;
        return {
          x: (e.touches[0].clientX - rect.left) * scaleX,
          y: (e.touches[0].clientY - rect.top) * scaleY
        };
      }
      return null;
    };

    const drawOnCanvas = (x1, y1, x2, y2, color, size)=>{
      if(!ctx) return;
      ctx.strokeStyle = color;
      ctx.lineWidth = size;
      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    };

    const clearCanvasLocal = ()=>{
      if(!ctx) return;
      ctx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
    };

    let lastPos = null;

    drawCanvas.addEventListener('mousedown', (e)=>{
      if(currentMode!=='draw' || !consentBox.checked || isMuted) return;
      isDrawing = true;
      lastPos = getMousePos(e);
    });

    drawCanvas.addEventListener('mousemove', (e)=>{
      if(!isDrawing || currentMode!=='draw') return;
      const pos = getMousePos(e);
      if(lastPos){
        drawOnCanvas(lastPos.x, lastPos.y, pos.x, pos.y, currentColor, currentBrushSize);
        const msg = {type:'draw', x:lastPos.x, y:lastPos.y, x2:pos.x, y2:pos.y, color:currentColor, size:currentBrushSize};
        broadcast(msg);
      }
      lastPos = pos;
    });

    drawCanvas.addEventListener('mouseup', ()=>{ isDrawing=false; lastPos=null; });
    drawCanvas.addEventListener('mouseleave', ()=>{ isDrawing=false; lastPos=null; });

    // Touch support
    drawCanvas.addEventListener('touchstart', (e)=>{
      if(currentMode!=='draw' || !consentBox.checked || isMuted) return;
      e.preventDefault();
      isDrawing = true;
      lastPos = getTouchPos(e);
    }, {passive:false});

    drawCanvas.addEventListener('touchmove', (e)=>{
      if(!isDrawing || currentMode!=='draw') return;
      e.preventDefault();
      const pos = getTouchPos(e);
      if(lastPos && pos){
        drawOnCanvas(lastPos.x, lastPos.y, pos.x, pos.y, currentColor, currentBrushSize);
        const msg = {type:'draw', x:lastPos.x, y:lastPos.y, x2:pos.x, y2:pos.y, color:currentColor, size:currentBrushSize};
        broadcast(msg);
        lastPos = pos;
      }
    }, {passive:false});

    drawCanvas.addEventListener('touchend', ()=>{ isDrawing=false; lastPos=null; });

    // Color picker
    document.querySelectorAll('.color-btn').forEach(btn=>{
      btn.addEventListener('click', ()=>{
        document.querySelectorAll('.color-btn').forEach(b=>b.classList.remove('active'));
        btn.classList.add('active');
        currentColor = btn.dataset.color;
      });
    });

    brushSize.addEventListener('input', ()=>{
      currentBrushSize = parseInt(brushSize.value);
    });

    clearCanvas.addEventListener('click', ()=>{
      clearCanvasLocal();
      broadcast({type:'clear-canvas'});
      log('Canvas cleared.');
    });

    // Screen sharing
    const peerConnections = new Map(); // peerId -> RTCPeerConnection for screen sharing

    const startScreenShare = async ()=>{
      try{
        screenStream = await navigator.mediaDevices.getDisplayMedia({video: true, audio: true});
        isSharing = true;
        shareScreenBtn.textContent = 'üõë Stop Sharing';
        screenVideo.srcObject = screenStream;
        screenContainer.style.display = 'block';
        presenterName.textContent = 'You';
        
        broadcast({type:'screen-start', presenter: peer?.id || 'You'});
        
        // Create peer connections for each viewer
        conns.forEach(async (conn, peerId)=>{
          const pc = new RTCPeerConnection({iceServers: [{urls: 'stun:stun.l.google.com:19302'}]});
          peerConnections.set(peerId, pc);
          
          screenStream.getTracks().forEach(track => pc.addTrack(track, screenStream));
          
          pc.onicecandidate = (e)=>{
            if(e.candidate){
              conn.send({type:'screen-ice', candidate: e.candidate});
            }
          };
          
          const offer = await pc.createOffer();
          await pc.setLocalDescription(offer);
          conn.send({type:'screen-offer', offer: offer});
        });
        
        screenStream.getTracks()[0].onended = ()=> stopScreenShare();
        log('Screen sharing started');
      }catch(e){
        log(`Screen share error: ${e.message}`);
      }
    };

    const stopScreenShare = ()=>{
      if(screenStream){
        screenStream.getTracks().forEach(t => t.stop());
        screenStream = null;
      }
      peerConnections.forEach(pc => pc.close());
      peerConnections.clear();
      isSharing = false;
      shareScreenBtn.textContent = 'üì∫ Share Screen';
      stopScreenDisplay();
      broadcast({type:'screen-stop', presenter: peer?.id || 'You'});
      log('Screen sharing stopped');
    };

    const stopScreenDisplay = ()=>{
      screenContainer.style.display = 'none';
      if(screenVideo.srcObject){
        screenVideo.srcObject.getTracks().forEach(t => t.stop());
        screenVideo.srcObject = null;
      }
      currentPresenter = null;
    };

    const handleScreenOffer = async (data, fromId)=>{
      const pc = new RTCPeerConnection({iceServers: [{urls: 'stun:stun.l.google.com:19302'}]});
      peerConnections.set(fromId, pc);
      
      pc.ontrack = (e)=>{
        screenVideo.srcObject = e.streams[0];
      };
      
      pc.onicecandidate = (e)=>{
        if(e.candidate){
          const conn = conns.get(fromId);
          if(conn?.open) conn.send({type:'screen-ice', candidate: e.candidate});
        }
      };
      
      await pc.setRemoteDescription(new RTCSessionDescription(data.offer));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      
      const conn = conns.get(fromId);
      if(conn?.open) conn.send({type:'screen-answer', answer: answer});
    };

    const handleScreenAnswer = async (data)=>{
      const pc = peerConnections.get(data.peerId);
      if(pc){
        await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
      }
    };

    const handleScreenIce = async (data)=>{
      const pc = Array.from(peerConnections.values())[0];
      if(pc && data.candidate){
        await pc.addIceCandidate(new RTCIceCandidate(data.candidate));
      }
    };

    shareScreenBtn.addEventListener('click', ()=>{
      if(isSharing) stopScreenShare();
      else startScreenShare();
    });

    // Network hint
    window.addEventListener('offline', ()=>log('Browser went offline.'));
    window.addEventListener('online', ()=>log('Browser is online.'));
    
    // Initialize to text mode
    setMode('text');
  })();
  </script>
</body>
</html>
